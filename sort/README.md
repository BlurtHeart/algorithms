# 排序

## 冒泡排序

### 基本思想

    在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

### 示例

    初始状态：2, 3, 2, 5, 1
    2 < 3, pass
    3 > 2, 交换位置，变为2, 2, 3, 5, 1
    3 < 5, pass
    5 > 1, 交换位置，变为2, 2, 3, 1, 5

以上第一次排序之后，最大的数5会排到最后边。重复以上步骤，除了最后一个已经找出来的最大数。这样最大的数会依次像冒泡一样冒到后边。

假设有n个元素，则需要n-1次排序才能将数组排序完毕。

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L3)    


## 快速排序

### 基本思想

1）选择一个基准元素,通常选择第一个元素或者最后一个元素,

2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。

3）此时基准元素在其排好序后的正确位置

4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

### 示例

#### 一趟排序的过程

1. 初始状态：2(i), 3, 2, 5, 1(j)  关键字：2
2. 第一次交换：1(i), 3, 2, 5, 2(j)
3. 第二次交换：1, 2(i), 2, 5, 3(j)
4. 最终状态：1, 2(i,j), 2, 5, 3

#### 排序的全过程

1. 初始状态：2, 3, 2, 5, 1  关键字：2
2. 一次排序后：(1), 2, (2, 5, 3)
3. 分别快速排序：(1), 2, (2), (5, 3) -> (1), 2, (2), (3, 5)
4. 有序序列：1, 2, 2, 3, 5

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L13) 


## 插入排序之直接插入排序

### 基本思想

将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**要点**：设立哨兵，作为临时存储和判断数组边界之用。

### 示例

1. 初始状态：2, 3, 2, 5, 1 哨兵:2
2. 第一次插入：2, 2, 3, 5, 1 哨兵:2
3. 第二次插入：1, 2, 2, 3, 5 哨兵:1
4. 排序完成

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L38) 


## 插入排序之希尔排序

### 基本思想

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

### 操作方法：

1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 示例

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/shell-sort.jpg)

### 算法实现

我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数

即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L74) 


## 选择排序

### 基本思想

在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。

### 示例

0. 初始状态：[49 38 65 97 76 13 27 49 55 4]
1. 第1次选择：[4 38 65 97 76 13 27 49 55 49]
2. 第2次选择：[4 13 65 97 76 38 27 49 55 49]
3. 第3次选择：[4 13 27 97 76 38 65 49 55 49]
4. 第4次选择：[4 13 27 38 76 97 65 49 55 49]
5. 第5次选择：[4 13 27 38 49 97 65 76 55 49]
6. 第6次选择：[4 13 27 38 49 49 65 76 55 97]
7. 第7次选择：[4 13 27 38 49 49 55 76 65 97]
8. 第8次选择：[4 13 27 38 49 49 55 65 76 97]
9. 第9次选择：[4 13 27 38 49 49 55 65 76 97]
10. 第10次选择：[4 13 27 38 49 49 55 65 76 97]

### 操作方法

第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；

第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；

以此类推.....

第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，

直到整个序列按关键码有序。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L84) 


## 双向选择排序

### 基本思想

双向选择排序是对选择排序的改进。

简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。

### 示例

0. 初始状态：[2 38 65 97 76 13 27 49 55 4]
1. 第1次选择：[2 38 65 4 76 13 27 49 55 97]
2. 第2次选择：[2 4 65 38 55 13 27 49 76 97]
3. 第3次选择：[2 4 13 38 55 49 27 65 76 97]
4. 第4次选择：[2 4 13 27 38 49 55 65 76 97]
5. 第5次选择：[2 4 13 27 38 49 55 65 76 97]

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L105) 


## 选择排序之堆排序

堆排序是一种树形选择排序，是对直接选择排序的有效改进。

### 基本思想

堆的定义如下：具有n个元素的序列（k1,k2,...,kn),当且仅当满足

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/heap-sort-defination.jpg)

时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。

若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：

a) 大顶堆序列：（96, 83,27,38,11,09)

b) 小顶堆序列：（12，36，24，85，47，30，53，91）

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/big-little-heap.jpg)

初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。

因此，实现堆排序需解决两个问题：

1. 如何将n 个待排序的数建成堆；
2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。

首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。

调整小顶堆的方法：

1. 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。
2. 将根结点与左、右子树中较小元素的进行交换。
3. 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.
4. 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.
5. 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。

称这个自根结点到叶子结点的调整过程为筛选。如图：

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/process-of-adjust-little-heap.jpg)


再讨论对n 个元素初始建堆的过程。

建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。

1. n 个结点的完全二叉树，则最后一个结点是第个结点的子树。
2. 筛选从第个结点为根的子树开始，该子树成为堆。
3. 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。

如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/heap-sort-init.jpg)

### 算法的实现

堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。

### 时间复杂度

    O(nlogn)