## SUDOKU

### 函数

- IsValidSudoku - 鉴定一个[][]byte是否是一个真实的数独

    A valid Sudoku board (partially filled) is not necessarily solvable.
    Only the filled cells need to be validated.

## Sudoku Solver

将空的单元格填满实现一个Sudoku的解法程序。空的单元格用'.'来表示。

### 例子

问题如下：

    5   3   .   .   7   .   .   .   .
    6   .   .   1   9   5   .   .   .
    .   9   8   .   .   .   .   6   .
    8   .   .   .   6   .   .   .   3
    4   .   .   8   .   3   .   .   1
    7   .   .   .   2   .   .   .   6
    .   6   .   .   .   .   2   8   .
    .   .   .   4   1   9   .   .   5
    .   .   .   .   8   .   .   7   9

答案如下：

    5   3   4   6   7   8   9   1   2
    6   7   2   1   9   5   3   4   8
    1   9   8   3   4   2   5   6   7
    8   5   9   7   6   1   4   2   3
    4   2   6   8   5   3   7   9   1
    7   1   3   9   2   4   8   5   6
    9   6   1   5   3   7   2   8   4
    2   8   7   4   1   9   6   3   5
    3   4   5   2   8   6   1   7   9

### 递归算法

*特性：*

1. Sudoku总共有`9 X 9 = 81`个数字
2. 每一个数字都不可以与它所在的行、列、单元格内的元素重复

根据以上两条特性，我们使用如下算法：

1. 为各行、各列、各单元格创建一个已使用数字列表
    - 创建一个节点noder，节点是一个已使用数字列表
    - 故整个Sudoku的已使用数字列表为二维数组[3][9]noder
2. 从第0个元素开始查询，直到查到第81个元素位置
3. 如果i处出现`.`（即空白处），则查询#1创建的访问列表，
找到一个未使用数字v
4. 如果找到v，填充到空白处，并更新访问列表，返回true
5. 如果没有找到v（即9个数字都已使用），则返回false
6. 如果#4返回true，从第i+1个元素开始查询，重复#3步骤。否则，回退#4，寻找
下一个未使用数字

整个算法采用了递归函数sudokuRecursion，此函数功能是完善下一个空白处的元素，
如果可以完善（即返回true），则说明调用者处于正确赋值状态。如果不能完善，则说明
调用者的赋值不可以达到最终答案，需要回退调用者的赋值，进行下一个赋值尝试。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/tree/master/sudoku/utils.go#L67)