# 排序

## 冒泡排序

### 基本思想

    在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

### 示例

    初始状态：2, 3, 2, 5, 1
    2 < 3, pass
    3 > 2, 交换位置，变为2, 2, 3, 5, 1
    3 < 5, pass
    5 > 1, 交换位置，变为2, 2, 3, 1, 5

以上第一次排序之后，最大的数5会排到最后边。重复以上步骤，除了最后一个已经找出来的最大数。这样最大的数会依次像冒泡一样冒到后边。

假设有n个元素，则需要n-1次排序才能将数组排序完毕。

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L3)    


## 快速排序

### 基本思想

1）选择一个基准元素,通常选择第一个元素或者最后一个元素,

2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。

3）此时基准元素在其排好序后的正确位置

4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

### 示例

#### 一趟排序的过程

1. 初始状态：2(i), 3, 2, 5, 1(j)  关键字：2
2. 第一次交换：1(i), 3, 2, 5, 2(j)
3. 第二次交换：1, 2(i), 2, 5, 3(j)
4. 最终状态：1, 2(i,j), 2, 5, 3

#### 排序的全过程

1. 初始状态：2, 3, 2, 5, 1  关键字：2
2. 一次排序后：(1), 2, (2, 5, 3)
3. 分别快速排序：(1), 2, (2), (5, 3) -> (1), 2, (2), (3, 5)
4. 有序序列：1, 2, 2, 3, 5

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L13) 


## 插入排序之直接插入排序

### 基本思想

将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**要点**：设立哨兵，作为临时存储和判断数组边界之用。

### 示例

1. 初始状态：2, 3, 2, 5, 1 哨兵:2
2. 第一次插入：2, 2, 3, 5, 1 哨兵:2
3. 第二次插入：1, 2, 2, 3, 5 哨兵:1
4. 排序完成

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L38) 


## 插入排序之希尔排序

### 基本思想

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

### 操作方法：

1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 示例

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/shell-sort.jpg)

### 算法实现

我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数

即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L74) 