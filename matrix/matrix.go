package matrix

/*
 * clockwise rotate
 * first reverse up to down, then swap the symmetry
 * 1 2 3     7 8 9     7 4 1
 * 4 5 6  => 4 5 6  => 8 5 2
 * 7 8 9     1 2 3     9 6 3
 */
func Rotate(matrix [][]int) {
	for i, j := 0, len(matrix)-1; i < j; i, j = i+1, j-1 {
		matrix[i], matrix[j] = matrix[j], matrix[i]
	}
	for i := 1; i < len(matrix); i++ {
		for j := 0; j < i; j++ {
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}
}

/*
 * anticlockwise rotate
 * first swap the symmetry, then reverse left to right
 * 1 2 3     1 4 7     3 6 9
 * 4 5 6  => 2 5 8  => 2 5 8
 * 7 8 9     3 6 9     1 4 7
 */
func AntiRotate(matrix [][]int) {
	for i := 1; i < len(matrix); i++ {
		for j := 0; j < i; j++ {
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}
	for i, j := 0, len(matrix)-1; i < j; i, j = i+1, j-1 {
		matrix[i], matrix[j] = matrix[j], matrix[i]
	}
}

// return all elements of the matrix in spiral order
func SpiralOrder(matrix [][]int) []int {
	var ret []int
	if len(matrix) == 0 {
		return ret
	}
	rowBegin, rowEnd := 0, len(matrix)-1
	columnBegin, columnEnd := 0, len(matrix[0])-1
	ret = make([]int, 0, len(matrix)*len(matrix[0]))

	for rowBegin <= rowEnd && columnBegin <= columnEnd {
		for i := columnBegin; i <= columnEnd; i++ {
			ret = append(ret, matrix[rowBegin][i])
		}
		rowBegin++

		for i := rowBegin; i <= rowEnd; i++ {
			ret = append(ret, matrix[i][columnEnd])
		}
		columnEnd--

		// if-condition is to avoid 1 x 3 matrix
		if rowBegin <= rowEnd {
			for i := columnEnd; i >= columnBegin; i-- {
				ret = append(ret, matrix[rowEnd][i])
			}
		}
		rowEnd--

		// if-condition is to avoid 3 x 1 matrix
		if columnBegin <= columnEnd {
			for i := rowEnd; i >= rowBegin; i-- {
				ret = append(ret, matrix[i][columnBegin])
			}
		}
		columnBegin++
	}
	return ret
}

// return a n * n matrix which is generated by spiral order
func GenerateSpiralMatrix(n int) [][]int {
	var ret [][]int
	if n < 1 {
		return ret
	}
	ret = make([][]int, n)
	for i := 0; i < n; i++ {
		ret[i] = make([]int, n)
	}

	var row, col int
	rowInc, colInc := 0, 1
	rowBegin, rowEnd := 0, n-1
	colBegin, colEnd := 0, n-1
	for i := 0; i < n*n; i++ {
		ret[row][col] = i + 1
		row += rowInc
		col += colInc
		if row > rowEnd {
			colEnd--
			row, col = rowEnd, colEnd
			rowInc, colInc = 0, -1
		} else if row < rowBegin {
			colBegin++
			row, col = rowBegin, colBegin
			rowInc, colInc = 0, 1
		} else if col > colEnd {
			rowBegin++
			row, col = rowBegin, colEnd
			rowInc, colInc = 1, 0
		} else if col < colBegin {
			rowEnd--
			row, col = rowEnd, colBegin
			rowInc, colInc = -1, 0
		}
	}
	return ret
}

// search for a value in an m x n matrix
// matrix has two properties:
// Integers in each row are sorted from left to right.
// The first integer of each row is greater than the last integer of the previous row.
func SearchMatrix(matrix [][]int, target int) bool {
	row := len(matrix)
	if row == 0 {
		return false
	}
	col := len(matrix[0])
	if col == 0 {
		return false
	}
	low, high := 0, row*col-1
	for low != high {
		mid := (low + high - 1) >> 1
		if matrix[mid/col][mid%col] < target {
			low = mid + 1
		} else {
			high = mid
		}
	}
	return matrix[low/col][low%col] == target
}

// if an element in matrix is 0, set its entire row and column to 0
// use constant space
func SetZeroes(matrix [][]int) {
	var rows, cols int
	if rows = len(matrix); rows == 0 {
		return
	}
	if cols = len(matrix[0]); cols == 0 {
		return
	}

	col0 := 1
	for i := 0; i < rows; i++ {
		if matrix[i][0] == 0 {
			col0 = 0
		}
		for j := 1; j < cols; j++ {
			if matrix[i][j] == 0 {
				matrix[i][0], matrix[0][j] = 0, 0
			}
		}
	}

	for i := rows - 1; i >= 0; i-- {
		for j := cols - 1; j > 0; j-- {
			if matrix[i][0] == 0 || matrix[0][j] == 0 {
				matrix[i][j] = 0
			}
		}
		if col0 == 0 {
			matrix[i][0] = 0
		}
	}
}
