# 排序

## 冒泡排序

### 基本思想

    在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

### 示例

    初始状态：2, 3, 2, 5, 1
    2 < 3, pass
    3 > 2, 交换位置，变为2, 2, 3, 5, 1
    3 < 5, pass
    5 > 1, 交换位置，变为2, 2, 3, 1, 5

以上第一次排序之后，最大的数5会排到最后边。重复以上步骤，除了最后一个已经找出来的最大数。这样最大的数会依次像冒泡一样冒到后边。

假设有n个元素，则需要n-1次排序才能将数组排序完毕。

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L3)    


## 快速排序

### 基本思想

1）选择一个基准元素,通常选择第一个元素或者最后一个元素,

2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。

3）此时基准元素在其排好序后的正确位置

4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

### 示例

#### 一趟排序的过程

1. 初始状态：2(i), 3, 2, 5, 1(j)  关键字：2
2. 第一次交换：1(i), 3, 2, 5, 2(j)
3. 第二次交换：1, 2(i), 2, 5, 3(j)
4. 最终状态：1, 2(i,j), 2, 5, 3

#### 排序的全过程

1. 初始状态：2, 3, 2, 5, 1  关键字：2
2. 一次排序后：(1), 2, (2, 5, 3)
3. 分别快速排序：(1), 2, (2), (5, 3) -> (1), 2, (2), (3, 5)
4. 有序序列：1, 2, 2, 3, 5

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L13) 


## 插入排序之直接插入排序

### 基本思想

将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

**要点**：设立哨兵，作为临时存储和判断数组边界之用。

### 示例

1. 初始状态：2, 3, 2, 5, 1 哨兵:2
2. 第一次插入：2, 2, 3, 5, 1 哨兵:2
3. 第二次插入：1, 2, 2, 3, 5 哨兵:1
4. 排序完成

### 时间复杂度

    n * (n-1) / 2 = O(n2)

### 代码
[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L38) 


## 插入排序之希尔排序

### 基本思想

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

### 操作方法：

1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 示例

![](https://github.com/BlurtHeart/markdownphotos/blob/master/algorithms/shell-sort.jpg)

### 算法实现

我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数

即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L74) 


## 选择排序

### 基本思想

在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。

### 示例

0. 初始状态：[49 38 65 97 76 13 27 49 55 4]
1. 第1次选择：[4 38 65 97 76 13 27 49 55 49]
2. 第2次选择：[4 13 65 97 76 38 27 49 55 49]
3. 第3次选择：[4 13 27 97 76 38 65 49 55 49]
4. 第4次选择：[4 13 27 38 76 97 65 49 55 49]
5. 第5次选择：[4 13 27 38 49 97 65 76 55 49]
6. 第6次选择：[4 13 27 38 49 49 65 76 55 97]
7. 第7次选择：[4 13 27 38 49 49 55 76 65 97]
8. 第8次选择：[4 13 27 38 49 49 55 65 76 97]
9. 第9次选择：[4 13 27 38 49 49 55 65 76 97]
10. 第10次选择：[4 13 27 38 49 49 55 65 76 97]

### 操作方法

第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；

第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；

以此类推.....

第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，

直到整个序列按关键码有序。

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L84) 


## 双向选择排序

### 基本思想

双向选择排序是对选择排序的改进。

简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。

### 示例

0. 初始状态：[2 38 65 97 76 13 27 49 55 4]
1. 第1次选择：[2 38 65 4 76 13 27 49 55 97]
2. 第2次选择：[2 4 65 38 55 13 27 49 76 97]
3. 第3次选择：[2 4 13 38 55 49 27 65 76 97]
4. 第4次选择：[2 4 13 27 38 49 55 65 76 97]
5. 第5次选择：[2 4 13 27 38 49 55 65 76 97]

### 代码

[传送门](https://github.com/BlurtHeart/algorithms/blob/master/sort/sort.go#L105) 